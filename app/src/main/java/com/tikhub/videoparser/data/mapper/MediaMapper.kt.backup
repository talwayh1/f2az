package com.tikhub.videoparser.data.mapper

import com.google.gson.JsonObject
import com.tikhub.videoparser.data.model.*
import timber.log.Timber

/**
 * æ•°æ®æ˜ å°„å™¨ï¼ˆMapperï¼‰
 *
 * èŒè´£ï¼šå°†å„å¹³å°çš„åŸå§‹ API å“åº”è½¬æ¢ä¸ºç»Ÿä¸€çš„ ParsedMedia æ¨¡å‹
 *
 * è®¾è®¡åŸåˆ™ï¼š
 * 1. æ¯ä¸ªå¹³å°ä¸€ä¸ªç‹¬ç«‹çš„è½¬æ¢æ–¹æ³•
 * 2. ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
 * 3. é˜²å¾¡æ€§ç¼–ç¨‹ï¼šæ‰€æœ‰å­—æ®µéƒ½è€ƒè™‘ null æƒ…å†µ
 * 4. æ™ºèƒ½åˆ¤æ–­å†…å®¹ç±»å‹ï¼ˆVideo vs ImageNoteï¼‰
 */
object MediaMapper {

    // ========================================
    // æŠ–éŸ³ Mapper
    // ========================================

    /**
     * è½¬æ¢æŠ–éŸ³æ•°æ®
     *
     * ç‰¹æ®Šé€»è¾‘ï¼š
     * - æŠ–éŸ³æœ‰"å›¾æ–‡ç¬”è®°"æ¨¡å¼ï¼ˆimages å­—æ®µä¸ä¸ºç©ºï¼‰
     * - ä¼˜å…ˆåˆ¤æ–­ imagesï¼Œå…¶æ¬¡æ‰æ˜¯ video
     * - å»æ°´å°é€»è¾‘ï¼šå°† playwm æ›¿æ¢ä¸º play
     */
    fun mapDouyin(data: DouyinVideoData): ParsedMedia {
        val detail = data.awemeDetail

        // åˆ¤æ–­å†…å®¹ç±»å‹ - æ›´ä¸¥æ ¼çš„éªŒè¯
        val imageUrls = detail.images?.mapNotNull { it.getFirstUrl() }?.filter { it.isNotBlank() } ?: emptyList()
        val hasImages = imageUrls.isNotEmpty()

        val hasVideo = detail.video != null &&
                      detail.video.playAddr != null &&
                      detail.video.playAddr.getFirstUrl()?.isNotBlank() == true

        // æ„å»ºç»Ÿè®¡ä¿¡æ¯
        val stats = StatsInfo(
            likeCount = detail.statistics.diggCount,
            commentCount = detail.statistics.commentCount,
            shareCount = detail.statistics.shareCount,
            collectCount = detail.statistics.collectCount,
            playCount = detail.statistics.playCount
        )

        // è·å–ä½œè€…å¤´åƒ
        val authorAvatar = detail.author.avatarThumb?.getFirstUrl() ?: ""

        return if (hasImages) {
            // å›¾æ–‡ç¬”è®°æ¨¡å¼ - imageUrls å·²ç»è¿‡æ»¤éªŒè¯ï¼Œç¡®ä¿éç©º
            Timber.d("æŠ–éŸ³å›¾æ–‡ç¬”è®°ï¼šå…± ${imageUrls.size} å¼ å›¾ç‰‡")
            ParsedMedia.ImageNote(
                id = detail.awemeId,
                platform = "douyin",
                authorName = detail.author.nickname,
                authorAvatar = authorAvatar,
                title = detail.desc ?: "æŠ–éŸ³å›¾æ–‡",
                coverUrl = imageUrls.firstOrNull() ?: "",
                stats = stats,
                createTime = detail.createTime,
                shareUrl = detail.shareUrl,
                imageUrls = imageUrls,
                imageSizes = detail.images?.map {
                    ImageSize(it.width, it.height, 0)
                } ?: emptyList()
            )
        } else if (hasVideo) {
            // è§†é¢‘æ¨¡å¼
            val video = detail.video!!

            // ğŸ¯ é€‰æ‹©æœ€é«˜æ¸…æ™°åº¦çš„è§†é¢‘ URLï¼ˆä» bit_rate åˆ—è¡¨ä¸­é€‰æ‹©æœ€é«˜ç ç‡ï¼‰
            val bestBitRate = video.bitRate?.maxByOrNull { it.bitRate }
            val playUrl = if (bestBitRate != null && bestBitRate.playAddr != null) {
                // ä½¿ç”¨æœ€é«˜ç ç‡çš„è§†é¢‘ URL
                bestBitRate.playAddr.getFirstUrl()
                    ?: video.playAddr!!.getFirstUrl()!! // é™çº§æ–¹æ¡ˆ
            } else {
                // æ²¡æœ‰ bit_rate æ•°æ®ï¼Œä½¿ç”¨é»˜è®¤ playAddr
                video.playAddr!!.getFirstUrl()!!
            }

            // éªŒè¯è§†é¢‘ URL æ˜¯å¦æœ‰æ•ˆ
            if (playUrl.isBlank()) {
                throw IllegalStateException("æŠ–éŸ³è§†é¢‘ URL ä¸ºç©º")
            }

            // æŠ–éŸ³å»æ°´å°é€»è¾‘ï¼šplaywm -> play
            val noWatermarkUrl = if (playUrl.contains("playwm")) {
                playUrl.replace("playwm", "play")
            } else {
                playUrl
            }

            val selectedBitrate = bestBitRate?.bitRate ?: video.bitRate?.firstOrNull()?.bitRate ?: 0
            val qualityInfo = bestBitRate?.gearName ?: "é»˜è®¤"
            Timber.d("æŠ–éŸ³è§†é¢‘ï¼šæ—¶é•¿=${video.duration}ms, åˆ†è¾¨ç‡=${video.width}x${video.height}, æ¸…æ™°åº¦=$qualityInfo, ç ç‡=$selectedBitrate")

            ParsedMedia.Video(
                id = detail.awemeId,
                platform = "douyin",
                authorName = detail.author.nickname,
                authorAvatar = authorAvatar,
                title = detail.desc ?: "æŠ–éŸ³è§†é¢‘",
                coverUrl = video.cover?.getFirstUrl() ?: "",
                stats = stats,
                createTime = detail.createTime,
                shareUrl = detail.shareUrl,
                videoUrl = noWatermarkUrl,
                duration = video.duration / 1000, // æ¯«ç§’è½¬ç§’
                width = video.width,
                height = video.height,
                fileSize = 0, // API æœªæä¾›
                bitrate = selectedBitrate,
                musicUrl = detail.music?.playUrl?.getFirstUrl(),
                musicTitle = detail.music?.title
            )
        } else {
            throw IllegalStateException("æŠ–éŸ³æ•°æ®è§£æå¤±è´¥ï¼šå†…å®¹æ—¢æ²¡æœ‰æœ‰æ•ˆå›¾ç‰‡ä¹Ÿæ²¡æœ‰æœ‰æ•ˆè§†é¢‘ (aweme_id=${detail.awemeId})")
        }
    }

    // ========================================
    // TikTok Mapper
    // ========================================

    /**
     * è½¬æ¢ TikTok æ•°æ®
     *
     * TikTok çš„ç»“æ„ä¸æŠ–éŸ³éå¸¸ç›¸ä¼¼
     */
    fun mapTikTok(data: TikTokVideoData): ParsedMedia {
        val detail = data.awemeDetail

        val stats = StatsInfo(
            likeCount = detail.statistics.diggCount,
            commentCount = detail.statistics.commentCount,
            shareCount = detail.statistics.shareCount,
            collectCount = detail.statistics.collectCount,
            playCount = detail.statistics.playCount
        )

        val video = detail.video
            ?: throw IllegalStateException("TikTok æ•°æ®ç¼ºå°‘ video å­—æ®µ")

        // ğŸ¯ é€‰æ‹©æœ€é«˜æ¸…æ™°åº¦çš„è§†é¢‘ URLï¼ˆä» bit_rate åˆ—è¡¨ä¸­é€‰æ‹©æœ€é«˜ç ç‡ï¼‰
        val bestBitRate = video.bitRate?.maxByOrNull { it.bitRate }
        val playUrl = if (bestBitRate != null && bestBitRate.playAddr != null) {
            // ä½¿ç”¨æœ€é«˜ç ç‡çš„è§†é¢‘ URL
            bestBitRate.playAddr.getFirstUrl()
                ?: video.playAddr?.getFirstUrl() ?: "" // é™çº§æ–¹æ¡ˆ
        } else {
            // æ²¡æœ‰ bit_rate æ•°æ®ï¼Œä½¿ç”¨é»˜è®¤ playAddr
            video.playAddr?.getFirstUrl() ?: ""
        }

        // TikTok å»æ°´å°é€»è¾‘ï¼ˆä¸æŠ–éŸ³ç›¸åŒï¼‰
        val noWatermarkUrl = if (playUrl.contains("playwm")) {
            playUrl.replace("playwm", "play")
        } else {
            playUrl
        }

        val selectedBitrate = bestBitRate?.bitRate ?: video.bitRate?.firstOrNull()?.bitRate ?: 0
        val qualityInfo = bestBitRate?.gearName ?: "é»˜è®¤"
        Timber.d("TikTokè§†é¢‘ï¼šæ—¶é•¿=${video.duration}ms, åˆ†è¾¨ç‡=${video.width}x${video.height}, æ¸…æ™°åº¦=$qualityInfo, ç ç‡=$selectedBitrate")

        return ParsedMedia.Video(
            id = detail.awemeId,
            platform = "tiktok",
            authorName = detail.author.nickname,
            authorAvatar = detail.author.avatarThumb?.getFirstUrl() ?: "",
            title = detail.desc ?: "TikTok video",
            coverUrl = video.cover?.getFirstUrl() ?: "",
            stats = stats,
            createTime = detail.createTime,
            shareUrl = detail.shareUrl,
            videoUrl = noWatermarkUrl,
            duration = video.duration / 1000,
            width = video.width,
            height = video.height,
            fileSize = 0,
            bitrate = selectedBitrate,
            musicUrl = detail.music?.playUrl?.getFirstUrl(),
            musicTitle = detail.music?.title
        )
    }

    // ========================================
    // å°çº¢ä¹¦ Mapper
    // ========================================

    /**
     * è½¬æ¢å°çº¢ä¹¦æ•°æ®
     *
     * ç‰¹æ®Šé€»è¾‘ï¼š
     * - å°çº¢ä¹¦ä»¥å›¾æ–‡ä¸ºä¸»ï¼Œä¹Ÿæ”¯æŒè§†é¢‘ç¬”è®°
     * - éœ€è¦ä»å¤æ‚çš„åµŒå¥—ç»“æ„ä¸­æå–æ•°æ®
     * - ç»Ÿè®¡æ•°æ®å­—æ®µåç§°ä¸æŠ–éŸ³ä¸åŒ
     */
    fun mapXiaohongshu(data: XiaohongshuNoteData): ParsedMedia {
        // å°çº¢ä¹¦çš„æ•°æ®ç»“æ„ï¼šdata.data[0].note_list[0]
        // æ›´å®‰å…¨çš„å¤šå±‚çº§ null æ£€æŸ¥
        val noteDetail = data.data?.firstOrNull()?.noteList?.firstOrNull()
            ?: throw IllegalStateException("å°çº¢ä¹¦æ•°æ®ç»“æ„å¼‚å¸¸ï¼šç¼ºå°‘ note_list (code=${data.code}, success=${data.success}, message=${data.message})")

        // éªŒè¯ç¬”è®° ID
        if (noteDetail.id.isNullOrBlank()) {
            throw IllegalStateException("å°çº¢ä¹¦ç¬”è®° ID ä¸ºç©º")
        }

        // åˆ¤æ–­æ˜¯å¦ä¸ºè§†é¢‘ç¬”è®°ï¼Œä¸”è§†é¢‘æ•°æ®æœ‰æ•ˆ
        val isVideo = noteDetail.type == "video" &&
                      noteDetail.video != null &&
                      noteDetail.video.url?.isNotBlank() == true

        val stats = StatsInfo(
            likeCount = noteDetail.likedCount.toLong(),
            commentCount = noteDetail.commentsCount.toLong(),
            shareCount = noteDetail.sharedCount.toLong(),
            collectCount = noteDetail.collectedCount.toLong(),
            playCount = noteDetail.viewCount.toLong()
        )

        val authorAvatar = noteDetail.user?.image ?: ""
        val authorName = noteDetail.user?.nickname
            ?: noteDetail.user?.name
            ?: "å°çº¢ä¹¦ç”¨æˆ·"

        return if (isVideo) {
            // è§†é¢‘ç¬”è®°
            val video = noteDetail.video!!

            // ğŸ¯ ä» urlInfoList ä¸­é€‰æ‹©æœ€ä½³è´¨é‡ï¼ˆä¼˜å…ˆ H264 é«˜ç ç‡ï¼Œå…¼å®¹æ€§æ›´å¥½ï¼‰
            val h264Videos = video.urlInfoList
                ?.filter { it.desc?.contains("h264", ignoreCase = true) == true }
                ?: emptyList()

            val h265Videos = video.urlInfoList
                ?.filter { it.desc?.contains("h265", ignoreCase = true) == true }
                ?: emptyList()

            // é€‰æ‹©æœ€é«˜ç ç‡çš„ H264 è§†é¢‘ï¼Œå¦‚æœæ²¡æœ‰åˆ™é€‰æ‹©æœ€é«˜ç ç‡çš„ H265
            val bestH264 = h264Videos.maxByOrNull { it.avgBitrate }
            val bestH265 = h265Videos.maxByOrNull { it.avgBitrate }

            val bestQuality = bestH264 ?: bestH265 ?: video.urlInfoList?.firstOrNull()
            val videoUrl = bestQuality?.url
                ?.takeIf { it.isNotBlank() }
                ?: video.url
                ?: throw IllegalStateException("å°çº¢ä¹¦è§†é¢‘ URL ä¸ºç©º (note_id=${noteDetail.id})")

            if (videoUrl.isBlank()) {
                throw IllegalStateException("å°çº¢ä¹¦è§†é¢‘ URL ä¸ºç©ºå­—ç¬¦ä¸² (note_id=${noteDetail.id})")
            }

            val codecInfo = when {
                bestH264 != null -> "H264"
                bestH265 != null -> "H265"
                else -> "é»˜è®¤"
            }
            val bitrateInfo = bestQuality?.avgBitrate ?: video.avgBitrate
            Timber.d("å°çº¢ä¹¦è§†é¢‘ç¬”è®°ï¼š${noteDetail.id}, ç¼–ç =$codecInfo, ç ç‡=$bitrateInfo, æ—¶é•¿=${video.duration}s, åˆ†è¾¨ç‡=${video.width}x${video.height}")

            // åˆå¹¶æ ‡é¢˜å’Œæè¿°ä½œä¸ºå®Œæ•´æ–‡æ¡ˆï¼ˆæ›´å¥å£®çš„é€»è¾‘ï¼‰
            val fullContent = buildString {
                val titleText = noteDetail.title?.trim()
                val descText = noteDetail.desc?.trim()

                if (!titleText.isNullOrBlank()) {
                    append(titleText)
                }

                if (!descText.isNullOrBlank()) {
                    if (isNotEmpty() && descText != titleText) {
                        append("\n\n")
                    }
                    if (descText != titleText) {
                        append(descText)
                    }
                }

                if (isEmpty()) {
                    append("å°çº¢ä¹¦è§†é¢‘ç¬”è®°")
                }
            }

            ParsedMedia.Video(
                id = noteDetail.id,
                platform = "xiaohongshu",
                authorName = authorName,
                authorAvatar = authorAvatar,
                title = fullContent,
                coverUrl = noteDetail.imagesList?.firstOrNull()?.url ?: "",
                stats = stats,
                createTime = noteDetail.time,
                shareUrl = noteDetail.shareInfo?.link,
                videoUrl = videoUrl,
                duration = video.duration,
                width = bestQuality?.width ?: video.width,
                height = bestQuality?.height ?: video.height,
                fileSize = 0,
                bitrate = bitrateInfo.toLong()
            )
        } else {
            // å›¾æ–‡ç¬”è®° - éªŒè¯å›¾ç‰‡åˆ—è¡¨
            val imagesList = noteDetail.imagesList ?: emptyList()

            // æå–æœ‰æ•ˆçš„å›¾ç‰‡ URLï¼ˆè¿‡æ»¤ç©ºç™½å’Œ nullï¼‰
            val validImageUrls = imagesList
                .mapNotNull { it.url ?: it.original }
                .filter { it.isNotBlank() }

            if (validImageUrls.isEmpty()) {
                throw IllegalStateException("å°çº¢ä¹¦å›¾æ–‡ç¬”è®°ç¼ºå°‘æœ‰æ•ˆå›¾ç‰‡ (note_id=${noteDetail.id}, type=${noteDetail.type})")
            }

            // åˆå¹¶æ ‡é¢˜å’Œæè¿°ä½œä¸ºå®Œæ•´æ–‡æ¡ˆ
            val fullContent = buildString {
                val titleText = noteDetail.title?.trim()
                val descText = noteDetail.desc?.trim()

                if (!titleText.isNullOrBlank()) {
                    append(titleText)
                }

                if (!descText.isNullOrBlank()) {
                    if (isNotEmpty() && descText != titleText) {
                        append("\n\n")
                    }
                    if (descText != titleText) {
                        append(descText)
                    }
                }

                if (isEmpty()) {
                    append("å°çº¢ä¹¦å›¾æ–‡ç¬”è®°")
                }
            }

            Timber.d("å°çº¢ä¹¦å›¾æ–‡ç¬”è®°ï¼š${noteDetail.id}, å…± ${validImageUrls.size} å¼ å›¾ç‰‡")

            ParsedMedia.ImageNote(
                id = noteDetail.id,
                platform = "xiaohongshu",
                authorName = authorName,
                authorAvatar = authorAvatar,
                title = fullContent,
                coverUrl = validImageUrls.firstOrNull() ?: "",
                stats = stats,
                createTime = noteDetail.time ?: 0,
                shareUrl = noteDetail.shareInfo?.link,
                imageUrls = validImageUrls,
                imageSizes = imagesList.map {
                    ImageSize(it.width ?: 0, it.height ?: 0, 0)
                }
            )
        }
    }

    // ========================================
    // å¿«æ‰‹ Mapper
    // ========================================

    /**
     * è½¬æ¢å¿«æ‰‹æ•°æ®
     */
    fun mapKuaishou(data: KuaishouVideoData): ParsedMedia {
        Timber.d("å¼€å§‹è§£æå¿«æ‰‹è§†é¢‘æ•°æ®")

        try {
            val photo = data.photo
            Timber.d("å¿«æ‰‹è§†é¢‘åŸºç¡€ä¿¡æ¯ - ID: ${photo.photoId}, æ ‡é¢˜: ${photo.caption}")

            val stats = StatsInfo(
                likeCount = photo.likeCount,
                commentCount = photo.commentCount,
                shareCount = photo.shareCount,
                collectCount = 0,
                playCount = photo.viewCount
            )

            // ğŸ¯ ä» mainMvUrls ä¸­é€‰æ‹©æœ€é«˜è´¨é‡çš„è§†é¢‘
            // å¿«æ‰‹çš„ quality_tag é€šå¸¸æœ‰: "normal", "super", "hd" ç­‰
            // ä¼˜å…ˆçº§: hd > super > normal
            val videoUrls = photo.mainMvUrls

            // è¯¦ç»†çš„æ—¥å¿—è®°å½•ç”¨äºè°ƒè¯•
            when {
                videoUrls == null -> {
                    Timber.e("å¿«æ‰‹è§†é¢‘è§£æå¤±è´¥: mainMvUrls ä¸º null")
                    throw IllegalStateException("å¿«æ‰‹è§†é¢‘ URL åˆ—è¡¨ä¸ºç©º")
                }
                videoUrls.isEmpty() -> {
                    Timber.e("å¿«æ‰‹è§†é¢‘è§£æå¤±è´¥: mainMvUrls ä¸ºç©ºåˆ—è¡¨")
                    Timber.e("å¯ç”¨æ•°æ®: photoId=${photo.photoId}, caption=${photo.caption}")
                    throw IllegalStateException("å¿«æ‰‹è§†é¢‘ URL åˆ—è¡¨ä¸ºç©º")
                }
                else -> {
                    Timber.d("å¿«æ‰‹è§†é¢‘å¯ç”¨ URL æ•°é‡: ${videoUrls.size}")
                    videoUrls.forEachIndexed { index, url ->
                        Timber.d("è§†é¢‘ URL $index: quality=${url.qualityTag}, url=${url.url}")
                    }
                }
            }

            val videoUrl = when {
                // ä¼˜å…ˆé€‰æ‹© HD è´¨é‡
                videoUrls.any { it.qualityTag?.contains("hd", ignoreCase = true) == true } -> {
                    val hdUrl = videoUrls.first { it.qualityTag?.contains("hd", ignoreCase = true) == true }
                    Timber.d("å¿«æ‰‹è§†é¢‘ï¼šé€‰æ‹© HD è´¨é‡")
                    hdUrl.url ?: run {
                        Timber.e("å¿«æ‰‹ HD è§†é¢‘è´¨é‡æ ‡ç­¾å­˜åœ¨ä½† URL ä¸ºç©º")
                        throw IllegalStateException("å¿«æ‰‹ HD è§†é¢‘ URL ä¸ºç©º")
                    }
                }

                // å…¶æ¬¡é€‰æ‹© Super è´¨é‡
                videoUrls.any { it.qualityTag?.contains("super", ignoreCase = true) == true } -> {
                    val superUrl = videoUrls.first { it.qualityTag?.contains("super", ignoreCase = true) == true }
                    Timber.d("å¿«æ‰‹è§†é¢‘ï¼šé€‰æ‹© Super è´¨é‡")
                    superUrl.url ?: run {
                        Timber.e("å¿«æ‰‹ Super è§†é¢‘è´¨é‡æ ‡ç­¾å­˜åœ¨ä½† URL ä¸ºç©º")
                        throw IllegalStateException("å¿«æ‰‹ Super è§†é¢‘ URL ä¸ºç©º")
                    }
                }

                // é™çº§åˆ°ç¬¬ä¸€ä¸ªå¯ç”¨URL
                else -> {
                    val firstUrl = videoUrls.first()
                    Timber.d("å¿«æ‰‹è§†é¢‘ï¼šä½¿ç”¨é»˜è®¤è´¨é‡ (quality=${firstUrl.qualityTag})")
                    firstUrl.url ?: run {
                        Timber.e("å¿«æ‰‹é»˜è®¤è§†é¢‘ URL ä¸ºç©ºï¼ŒqualityTag=${firstUrl.qualityTag}")
                        throw IllegalStateException("å¿«æ‰‹è§†é¢‘ URL ä¸ºç©º")
                    }
                }
            }

        val result = ParsedMedia.Video(
                id = photo.photoId,
                platform = "kuaishou",
                authorName = photo.userInfo.userName,
                authorAvatar = photo.userInfo.headUrl ?: "",
                title = photo.caption ?: "å¿«æ‰‹è§†é¢‘",
                coverUrl = photo.coverUrls?.firstOrNull()?.url ?: "",
                stats = stats,
                createTime = photo.timestamp,
                shareUrl = photo.shareInfo?.shareUrl,
                videoUrl = videoUrl,
                duration = photo.duration / 1000,
                width = photo.width,
                height = photo.height,
                fileSize = 0,
                bitrate = 0
            )

            Timber.d("å¿«æ‰‹è§†é¢‘è§£ææˆåŠŸ: ${result.title}")
            return result

        } catch (e: Exception) {
            Timber.e(e, "å¿«æ‰‹è§†é¢‘æ•°æ®æ˜ å°„å¤±è´¥")
            // è®°å½•æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ç”¨äºè°ƒè¯•
            Timber.e("é”™è¯¯è¯¦æƒ…: ${e.message}")
            Timber.e("æ•°æ®ç»“æ„: { photoId: ${data.photo.photoId}, caption: ${data.photo.caption} }")
            throw e
        }
    }

    // ========================================
    // Bç«™ Mapper
    // ========================================

    /**
     * è½¬æ¢ Bç«™ æ•°æ®
     */
    fun mapBilibili(data: BilibiliVideoData): ParsedMedia {
        val videoData = data.data
            ?: throw IllegalStateException("Bç«™æ•°æ®ç¼ºå°‘ data å­—æ®µ")

        val stats = StatsInfo(
            likeCount = videoData.stat?.like?.toLong() ?: 0,
            commentCount = videoData.stat?.reply?.toLong() ?: 0,
            shareCount = videoData.stat?.share?.toLong() ?: 0,
            collectCount = videoData.stat?.favorite?.toLong() ?: 0,
            playCount = videoData.stat?.view?.toLong() ?: 0
        )

        // æ³¨æ„ï¼šBç«™çš„è§†é¢‘æ’­æ”¾åœ°å€éœ€è¦é¢å¤–çš„ API è°ƒç”¨è·å–
        // è¿™é‡Œä»…ä¿å­˜åŸºç¡€ä¿¡æ¯ï¼Œå®é™…æ’­æ”¾åœ°å€éœ€è¦é€šè¿‡ cid å’Œ bvid è·å–
        return ParsedMedia.Video(
            id = videoData.bvid ?: videoData.aid?.toString() ?: "",
            platform = "bilibili",
            authorName = videoData.owner?.name ?: "Bç«™ç”¨æˆ·",
            authorAvatar = videoData.owner?.face ?: "",
            title = videoData.title ?: "Bç«™è§†é¢‘",
            coverUrl = videoData.pic ?: "",
            stats = stats,
            createTime = videoData.ctime,
            shareUrl = "https://www.bilibili.com/video/${videoData.bvid}",
            videoUrl = "", // Bç«™éœ€è¦é¢å¤– API è·å–çœŸå®æ’­æ”¾åœ°å€
            duration = videoData.duration,
            width = videoData.dimension?.width ?: 0,
            height = videoData.dimension?.height ?: 0,
            fileSize = 0,
            bitrate = 0
        )
    }

    // ========================================
    // å¾®åš Mapperï¼ˆæ–°å¢ï¼‰
    // ========================================

    /**
     * è½¬æ¢å¾®åšæ•°æ®
     *
     * å¾®åšç‰¹æ®Šæ€§ï¼š
     * - æ”¯æŒè§†é¢‘å¾®åšå’Œä¹å®«æ ¼å›¾æ–‡å¾®åš
     * - é€šè¿‡ page_info.type åˆ¤æ–­æ˜¯å¦ä¸ºè§†é¢‘
     * - å›¾æ–‡å¾®åšé€šè¿‡ pics å­—æ®µè·å–å›¾ç‰‡åˆ—è¡¨
     */
    fun mapWeibo(json: JsonObject): ParsedMedia {
        Timber.d("å¼€å§‹è§£æå¾®åšæ•°æ®")

        // å¾®åš API è¿”å›çš„ status å¯¹è±¡
        val status = json.getAsJsonObject("status")
            ?: throw IllegalStateException("å¾®åšæ•°æ®ç¼ºå°‘ status å­—æ®µ")

        val user = status.getAsJsonObject("user")
        val pageInfo = status.getAsJsonObject("page_info")

        // åˆ¤æ–­æ˜¯å¦ä¸ºè§†é¢‘å¾®åš
        val isVideo = pageInfo != null &&
                pageInfo.get("type")?.asString == "video" &&
                pageInfo.getAsJsonObject("media_info") != null

        // æ„å»ºç»Ÿè®¡ä¿¡æ¯
        val stats = StatsInfo(
            likeCount = status.get("attitudes_count")?.asLong ?: 0,
            commentCount = status.get("comments_count")?.asLong ?: 0,
            shareCount = status.get("reposts_count")?.asLong ?: 0,
            collectCount = 0,
            playCount = 0
        )

        val authorName = user?.get("screen_name")?.asString ?: "å¾®åšç”¨æˆ·"
        val authorAvatar = user?.get("avatar_large")?.asString ?: ""
        val title = status.get("text_raw")?.asString ?: "å¾®åšå†…å®¹"
        val id = status.get("id")?.asString ?: ""

        return if (isVideo) {
            // è§†é¢‘å¾®åš
            val mediaInfo = pageInfo.getAsJsonObject("media_info")
            val videoUrl = mediaInfo.get("stream_url_hd")?.asString
                ?: mediaInfo.get("stream_url")?.asString
                ?: throw IllegalStateException("å¾®åšè§†é¢‘ URL ä¸ºç©º")

            val coverUrl = pageInfo.getAsJsonObject("page_pic")?.get("url")?.asString ?: ""

            ParsedMedia.Video(
                id = id,
                platform = "weibo",
                authorName = authorName,
                authorAvatar = authorAvatar,
                title = title,
                coverUrl = coverUrl,
                stats = stats,
                createTime = status.get("created_at")?.asLong ?: 0,
                shareUrl = null,
                videoUrl = videoUrl,
                duration = mediaInfo.get("duration")?.asInt ?: 0,
                width = 0,
                height = 0,
                fileSize = 0,
                bitrate = 0
            )
        } else {
            // å›¾æ–‡å¾®åšï¼ˆä¹å®«æ ¼ï¼‰
            val pics = status.getAsJsonArray("pics")
            if (pics == null || pics.size() == 0) {
                throw IllegalStateException("å¾®åšå›¾æ–‡å†…å®¹ç¼ºå°‘å›¾ç‰‡")
            }

            val imageUrls = mutableListOf<String>()
            for (i in 0 until pics.size()) {
                val pic = pics[i].asJsonObject
                val large = pic.getAsJsonObject("large")
                val url = large?.get("url")?.asString
                if (url != null) {
                    imageUrls.add(url)
                }
            }

            ParsedMedia.ImageNote(
                id = id,
                platform = "weibo",
                authorName = authorName,
                authorAvatar = authorAvatar,
                title = title,
                coverUrl = imageUrls.firstOrNull() ?: "",
                stats = stats,
                createTime = status.get("created_at")?.asLong ?: 0,
                shareUrl = null,
                imageUrls = imageUrls,
                imageSizes = null
            )
        }
    }

    // ========================================
    // è¥¿ç“œè§†é¢‘ Mapperï¼ˆæ–°å¢ï¼‰
    // ========================================

    /**
     * è½¬æ¢è¥¿ç“œè§†é¢‘æ•°æ®
     *
     * è¥¿ç“œè§†é¢‘ç‰¹ç‚¹ï¼š
     * - ä»¥æ¨ªå±è§†é¢‘ä¸ºä¸»
     * - æ•°æ®ç»“æ„ä¸æŠ–éŸ³ç›¸ä¼¼ï¼ˆåŒå±å­—èŠ‚è·³åŠ¨ï¼‰
     */
    fun mapXigua(data: XiguaVideoData): ParsedMedia {
        Timber.d("å¼€å§‹è§£æè¥¿ç“œè§†é¢‘æ•°æ®")

        val itemInfo = data.itemInfo

        val stats = StatsInfo(
            likeCount = itemInfo.stats.diggCount,
            commentCount = itemInfo.stats.commentCount,
            shareCount = itemInfo.stats.shareCount,
            collectCount = 0,
            playCount = itemInfo.stats.playCount
        )

        // ğŸ¯ ä¼˜å…ˆé€‰æ‹© download_addrï¼ˆé€šå¸¸è´¨é‡æ›´é«˜ï¼‰ï¼Œç„¶åæ˜¯ play_addr
        val downloadUrls = itemInfo.video.downloadAddr?.urlList ?: emptyList()
        val playUrls = itemInfo.video.playAddr?.urlList ?: emptyList()

        val videoUrl = when {
            downloadUrls.isNotEmpty() -> {
                Timber.d("è¥¿ç“œè§†é¢‘ï¼šä½¿ç”¨ download_addr (é«˜è´¨é‡)")
                downloadUrls.first()
            }
            playUrls.isNotEmpty() -> {
                Timber.d("è¥¿ç“œè§†é¢‘ï¼šä½¿ç”¨ play_addr (æ ‡å‡†è´¨é‡)")
                playUrls.first()
            }
            else -> throw IllegalStateException("è¥¿ç“œè§†é¢‘ URL ä¸ºç©º")
        }

        val coverUrl = itemInfo.video.cover?.urlList?.firstOrNull() ?: ""

        return ParsedMedia.Video(
            id = itemInfo.itemId,
            platform = "xigua",
            authorName = itemInfo.author.name,
            authorAvatar = itemInfo.author.avatarUrl ?: "",
            title = itemInfo.title ?: itemInfo.desc ?: "è¥¿ç“œè§†é¢‘",
            coverUrl = coverUrl,
            stats = stats,
            createTime = itemInfo.createTime,
            shareUrl = itemInfo.shareUrl,
            videoUrl = videoUrl,
            duration = itemInfo.video.duration / 1000,
            width = itemInfo.video.width,
            height = itemInfo.video.height,
            fileSize = 0,
            bitrate = 0
        )
    }

    // ========================================
    // Instagram Mapperï¼ˆæ–°å¢ï¼‰
    // ========================================

    /**
     * è½¬æ¢ Instagram æ•°æ®
     *
     * Instagram ç‰¹ç‚¹ï¼š
     * - æ”¯æŒå•å›¾ã€å•è§†é¢‘ã€è½®æ’­ï¼ˆCarouselï¼‰
     * - media_type: 1=å›¾ç‰‡, 2=è§†é¢‘, 8=è½®æ’­
     * - è½®æ’­å¯èƒ½åŒ…å«å›¾ç‰‡å’Œè§†é¢‘çš„æ··åˆ
     */
    fun mapInstagram(data: InstagramPostData): ParsedMedia {
        Timber.d("å¼€å§‹è§£æ Instagram æ•°æ®")

        val item = data.items?.firstOrNull()
            ?: throw IllegalStateException("Instagram æ•°æ®ç¼ºå°‘ items")

        val stats = StatsInfo(
            likeCount = item.likeCount,
            commentCount = item.commentCount,
            shareCount = 0,
            collectCount = 0,
            playCount = item.playCount
        )

        val authorName = item.user.username
        val authorAvatar = item.user.profilePicUrl ?: ""
        val title = item.caption?.text ?: "Instagram post"
        val id = item.id

        return when (item.mediaType) {
            1 -> {
                // å•å›¾ - ğŸ¯ é€‰æ‹©æœ€é«˜åˆ†è¾¨ç‡
                val bestImage = item.imageVersions?.candidates?.maxByOrNull { it.width * it.height }
                val imageUrl = bestImage?.url
                    ?: throw IllegalStateException("Instagram å›¾ç‰‡ URL ä¸ºç©º")

                Timber.d("Instagramå›¾ç‰‡ï¼šé€‰æ‹©æœ€é«˜åˆ†è¾¨ç‡ ${bestImage.width}x${bestImage.height}")

                ParsedMedia.ImageNote(
                    id = id,
                    platform = "instagram",
                    authorName = authorName,
                    authorAvatar = authorAvatar,
                    title = title,
                    coverUrl = imageUrl,
                    stats = stats,
                    createTime = item.takenAt,
                    shareUrl = "https://www.instagram.com/p/${item.code}/",
                    imageUrls = listOf(imageUrl),
                    imageSizes = item.imageVersions?.candidates?.map {
                        ImageSize(it.width, it.height, 0)
                    }
                )
            }
            2 -> {
                // å•è§†é¢‘ - ğŸ¯ é€‰æ‹©æœ€é«˜åˆ†è¾¨ç‡
                val bestVideo = item.videoVersions?.maxByOrNull { it.width * it.height }
                val videoUrl = bestVideo?.url
                    ?: throw IllegalStateException("Instagram è§†é¢‘ URL ä¸ºç©º")

                val coverImage = item.imageVersions?.candidates?.maxByOrNull { it.width * it.height }
                val coverUrl = coverImage?.url ?: ""

                Timber.d("Instagramè§†é¢‘ï¼šé€‰æ‹©æœ€é«˜åˆ†è¾¨ç‡ ${bestVideo.width}x${bestVideo.height}")

                ParsedMedia.Video(
                    id = id,
                    platform = "instagram",
                    authorName = authorName,
                    authorAvatar = authorAvatar,
                    title = title,
                    coverUrl = coverUrl,
                    stats = stats,
                    createTime = item.takenAt,
                    shareUrl = "https://www.instagram.com/p/${item.code}/",
                    videoUrl = videoUrl,
                    duration = 0, // Instagram API å¯èƒ½ä¸æä¾›
                    width = bestVideo.width,
                    height = bestVideo.height,
                    fileSize = 0,
                    bitrate = 0
                )
            }
            8 -> {
                // è½®æ’­ï¼ˆCarouselï¼‰- ğŸ¯ æå–æ‰€æœ‰å›¾ç‰‡å¹¶é€‰æ‹©æœ€é«˜åˆ†è¾¨ç‡
                val carouselMedia = item.carouselMedia
                    ?: throw IllegalStateException("Instagram è½®æ’­æ•°æ®ä¸ºç©º")

                val imageUrls = mutableListOf<String>()
                val imageSizes = mutableListOf<ImageSize>()

                for (media in carouselMedia) {
                    if (media.mediaType == 1 || media.mediaType == 8) {
                        // å›¾ç‰‡ - é€‰æ‹©æœ€é«˜åˆ†è¾¨ç‡
                        val bestImage = media.imageVersions?.candidates?.maxByOrNull { it.width * it.height }
                        if (bestImage != null) {
                            imageUrls.add(bestImage.url)
                            imageSizes.add(ImageSize(bestImage.width, bestImage.height, 0))
                            Timber.d("Instagramè½®æ’­å›¾ç‰‡ï¼š${bestImage.width}x${bestImage.height}")
                        }
                    }
                    // æ³¨æ„ï¼šå¦‚æœè½®æ’­ä¸­åŒ…å«è§†é¢‘ï¼Œè¿™é‡Œæš‚æ—¶å¿½ç•¥
                }

                if (imageUrls.isEmpty()) {
                    throw IllegalStateException("Instagram è½®æ’­ä¸­æ²¡æœ‰å¯ç”¨å›¾ç‰‡")
                }

                ParsedMedia.ImageNote(
                    id = id,
                    platform = "instagram",
                    authorName = authorName,
                    authorAvatar = authorAvatar,
                    title = title,
                    coverUrl = imageUrls.firstOrNull() ?: "",
                    stats = stats,
                    createTime = item.takenAt,
                    shareUrl = "https://www.instagram.com/p/${item.code}/",
                    imageUrls = imageUrls,
                    imageSizes = imageSizes
                )
            }
            else -> {
                throw IllegalStateException("ä¸æ”¯æŒçš„ Instagram åª’ä½“ç±»å‹: ${item.mediaType}")
            }
        }
    }

    // ========================================
    // YouTube Mapperï¼ˆæ–°å¢ï¼‰
    // ========================================

    /**
     * è½¬æ¢ YouTube æ•°æ®
     *
     * YouTube ç‰¹ç‚¹ï¼š
     * - é•¿è§†é¢‘ä¸ºä¸»
     * - æœ‰å¤šç§æ¸…æ™°åº¦çš„è§†é¢‘æµ
     * - éœ€è¦ä» formats ä¸­é€‰æ‹©æœ€ä½³è´¨é‡
     */
    fun mapYouTube(data: YouTubeVideoData): ParsedMedia {
        Timber.d("å¼€å§‹è§£æ YouTube æ•°æ®")

        val videoDetails = data.videoDetails

        val stats = StatsInfo(
            likeCount = 0, // YouTube API å¯èƒ½ä¸æä¾›ç‚¹èµæ•°
            commentCount = 0,
            shareCount = 0,
            collectCount = 0,
            playCount = videoDetails.viewCount
        )

        // ä» formats ä¸­é€‰æ‹©æœ€é«˜è´¨é‡çš„è§†é¢‘
        val formats = data.streamingData?.formats ?: emptyList()
        val adaptiveFormats = data.streamingData?.adaptiveFormats ?: emptyList()

        // ä¼˜å…ˆé€‰æ‹©åŒ…å«éŸ³è§†é¢‘çš„ formats
        val videoUrl = formats.maxByOrNull { it.bitrate }?.url
            ?: adaptiveFormats.filter { it.mimeType?.contains("video") == true }
                .maxByOrNull { it.bitrate }?.url
            ?: throw IllegalStateException("YouTube è§†é¢‘ URL ä¸ºç©º")

        val coverUrl = videoDetails.thumbnail?.thumbnails?.maxByOrNull { it.width * it.height }?.url ?: ""

        // è·å–è§†é¢‘åˆ†è¾¨ç‡
        val bestFormat = formats.maxByOrNull { it.width * it.height }
            ?: adaptiveFormats.filter { it.mimeType?.contains("video") == true }
                .maxByOrNull { it.width * it.height }

        return ParsedMedia.Video(
            id = videoDetails.videoId,
            platform = "youtube",
            authorName = videoDetails.author ?: "YouTube Creator",
            authorAvatar = "", // YouTube API å¯èƒ½ä¸ç›´æ¥æä¾›é¢‘é“å¤´åƒ
            title = videoDetails.title ?: "YouTube Video",
            coverUrl = coverUrl,
            stats = stats,
            createTime = 0, // YouTube API å¯èƒ½ä¸æä¾›
            shareUrl = "https://www.youtube.com/watch?v=${videoDetails.videoId}",
            videoUrl = videoUrl,
            duration = videoDetails.lengthSeconds,
            width = bestFormat?.width ?: 0,
            height = bestFormat?.height ?: 0,
            fileSize = bestFormat?.contentLength ?: 0,
            bitrate = bestFormat?.bitrate?.toLong() ?: 0
        )
    }

    // ========================================
    // é€šç”¨é”™è¯¯å¤„ç†
    // ========================================

    /**
     * å®‰å…¨è½¬æ¢ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
     */
    fun <T> safeMap(
        data: T,
        mapper: (T) -> ParsedMedia,
        platform: String
    ): Result<ParsedMedia> {
        return try {
            Timber.d("å¼€å§‹è½¬æ¢ $platform æ•°æ®")
            val result = mapper(data)
            Timber.i("âœ… $platform æ•°æ®è½¬æ¢æˆåŠŸ")
            Result.success(result)
        } catch (e: Exception) {
            Timber.e(e, "âŒ $platform æ•°æ®è½¬æ¢å¤±è´¥")
            Result.failure(e)
        }
    }
}
